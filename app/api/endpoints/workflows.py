from sys import path
path.append('.')
import pathlib
import tempfile, pathlib, shutil, re
from anyio.to_thread import run_sync

from fastapi import APIRouter, Path, Query, Form, Request, HTTPException, BackgroundTasks
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.concurrency import run_in_threadpool
from bioblend.galaxy.objects.wrappers import HistoryDatasetAssociation, HistoryDatasetCollectionAssociation


from app.bioblend_server.executor.workflow_manager import WorkflowManager
from app.api.schemas import workflow

router = APIRouter()
workflow_manager = WorkflowManager()

@router.get(
    "/{workflow_id}/form",
    response_class=HTMLResponse,
    summary="Get Dynamic Workflow Form",
    tags=["Workflows"]
)
async def get_workflow_form(
    workflow_id: str = Path(..., description="The ID of the Galaxy workflow."),
    history_id: str = Query(..., description="The ID of the history to select inputs from.")
):
    """
    Generates and returns a dynamic HTML form for a specific workflow.
    The form is populated with available datasets from the provided history.
    """
    try:
        # Get the wrapper objects needed by your service method
        workflow_obj = await run_in_threadpool(workflow_manager.gi_object.workflows.get, workflow_id)
        history_obj = await run_in_threadpool(workflow_manager.gi_object.histories.get, history_id)

        # Run the synchronous HTML build in a thread pool
        html_form = await run_in_threadpool(
            workflow_manager.build_input,
            workflow=workflow_obj,
            history=history_obj
        )
        return HTMLResponse(content=html_form)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to build workflow form: {e}")

@router.post(
    "/{workflow_id}/histories/{history_id}/execute",
    response_model=workflow.WorkflowExecutionResponse,
    summary="Execute a Workflow",
    tags=["Workflows"]
)
async def execute_workflow(
    request: Request,
    dummy_input: str = Form(None, description="Dummy input to force form rendering the form input for the galaxy execution"), # Adding dummy form value to input request form.
    workflow_id: str = Path(..., description="The ID of the Galaxy workflow to execute."),
    history_id: str = Path(..., description="The ID of the history for execution.")
):
    """
    Executes a workflow using input data submitted via a form.

    This endpoint expects a `multipart/form-data` submission, as generated by the `/form` endpoint.
    It parses the form, invokes the workflow, tracks it to completion, and returns the results.
    """
    try:
        form_data = await request.form()
        workflow_obj = await run_in_threadpool(workflow_manager.gi_object.workflows.get, workflow_id)
        history_obj = await run_in_threadpool(workflow_manager.gi_object.histories.get, history_id)
        workflow_details = await run_in_threadpool(workflow_manager.gi_object.gi.workflows.show_workflow, workflow_id)

        # Reconstruct the 'inputs' dictionary for BioBlend
        inputs = {}
        steps = workflow_details['steps']
        for step_id, step_details in steps.items():

            # Check if this step is an input step and is in the form data
            form_value = form_data.get(step_id)
            if form_value is None:
                continue

            # Differentiate between data inputs and parameter inputs
            if step_details['type'] in ['data_input', 'data_collection_input']:
                src = 'hdca' if step_details['type'] == 'data_collection_input' else 'hda'
                inputs[step_id] = {'src': src, 'id': form_value}

            elif step_details['type'] == 'parameter_input':
                inputs[step_id] = form_value

        # Run the entire synchronous workflow execution and tracking in a thread pool
        invocation_id, report, intermediate_outputs, final_outputs = await run_in_threadpool(
            workflow_manager.run_workflow,
            inputs=inputs,
            workflow=workflow_obj,
            history=history_obj
        )

        # Format the outputs using Pydantic schemas
        intermediate_outputs_formatted = []
        final_outputs_formatted = []

        for ds in final_outputs:
            if isinstance(ds, HistoryDatasetAssociation):
                final_outputs_formatted.append(
                            {
                            "id": ds.id,
                            "name": ds.name,
                            "visible": ds.visible,
                            "peek": workflow_manager.gi_object.gi.datasets.show_dataset(ds.id)['peek'],
                            "data_type": workflow_manager.gi_object.gi.datasets.show_dataset(ds.id)['data_type']
                        }
                    )
            elif isinstance(ds, HistoryDatasetCollectionAssociation):
                final_outputs_formatted.append(
                        {
                            "id": ds.id,
                            "name": ds.name,
                            "visible": ds.visible,
                            "collection_type": ds.collection_type,
                            "elements": [
                                {
                                    "identifier": e["element_identifier"],
                                    "name": e["object"]["name"],
                                    "id": e["object"]["id"],
                                    "peek": e["object"]["peek"],
                                    "data_type": workflow_manager.gi_object.gi.datasets.show_dataset(e["object"]["id"])['data_type']
                                }

                                for e in ds.elements
                            ]
                        }
                    )
                
        for ds in intermediate_outputs:
            if isinstance(ds, HistoryDatasetAssociation):
                intermediate_outputs_formatted.append(
                            {
                            "id": ds.id,
                            "name": ds.name,
                            "visible": ds.visible,
                            "peek": workflow_manager.gi_object.gi.datasets.show_dataset(ds.id)['peek'],
                            "data_type": workflow_manager.gi_object.gi.datasets.show_dataset(ds.id)['data_type']
                        }
                    )
            elif isinstance(ds, HistoryDatasetCollectionAssociation):
                intermediate_outputs_formatted.append(
                        {
                            "id": ds.id,
                            "name": ds.name,
                            "visible": ds.visible,
                            "collection_type": ds.collection_type,
                            "elements": [
                                {
                                    "identifier": e["element_identifier"],
                                    "name": e["object"]["name"],
                                    "id": e["object"]["id"],
                                    "peek": e["object"]["peek"],
                                    "data_type": workflow_manager.gi_object.gi.datasets.show_dataset(e["object"]["id"])['data_type']
                                }

                                for e in ds.elements
                            ]
                        }
                    )
                                        
        return {
                "invocation_id": invocation_id,
                "history_id": history_id,
                "report": report,
                "final_outputs": final_outputs_formatted,
                "intermediate_outputs": intermediate_outputs_formatted
            }
    except Exception as e:
        # Provide a detailed error message for debugging
        raise HTTPException(status_code=500, detail=f"Workflow execution failed: {e}")
    
@router.get(
    "/{workflow_id}/details",
    response_model=workflow.WorkflowDetails,
    summary="Get detailed information about the Galaxy workflow",
    tags=["Workflows"]
)
async def get_workflow_details(
    workflow_id: str = Path(..., description="The ID of the Galaxy workflow.")
):
    """
    Shows the details of a workflow including id, created time,
    annotations, published or not, creator, url, license, steps and inputs
    """

    try:
        workflow_details  = await run_in_threadpool(workflow_manager.gi_object.gi.workflows.show_workflow, workflow_id)
       
        return {
            "id": workflow_details.get("id"),
            "tags": workflow_details.get("tags", None),
            "create_time": workflow_details.get("create_time"),
            "annotations": workflow_details.get("annotations", None),
            "published": workflow_details.get("published"),
            "license": workflow_details.get("license", None),
            "galaxy_url": workflow_details.get("url"),
            "creator": workflow_details.get("creator", None),
            "steps": workflow_details.get("steps"),
            "inputs": workflow_details.get("inputs"),
        }
                
    except Exception as e:
        # detailed error responses
        raise HTTPException(status_code = 500 , detail= f'Show workflow failed {e}')


def _rmtree_sync(path: pathlib.Path):
    shutil.rmtree(path, ignore_errors=True)

# TODO: this needs an installation on galaxy instance side, to support pdf downloads
@router.get(
    "/{workflow_id}/invocation_pdf",
    response_class = FileResponse,
    summary= "Get invocation pdf report",
    tags=["Invocation", "Workflows"]
)
async def invocation_report_pdf(
    workflow_id: str = Path(..., description="The ID of the Galaxy workflow."),
    invocation_id: str = Query(..., description="The ID of the invocation from a certain workflow")
):
    tmpdir = tempfile.mkdtemp(prefix="galaxy_pdf_")
    tmpdir_path = pathlib.Path(tmpdir)
    try:
        # get workflow object 
        workflow_obj = await run_in_threadpool(
            workflow_manager.gi_object.workflows.get, workflow_id
        )

        pdf_report_name = re.sub(r'[\\/*?:"<>|]', '', f"{workflow_obj.name}_invocation_report.pdf")
        pdf_path = tmpdir_path / pdf_report_name

        await run_in_threadpool(
            workflow_manager.gi_object.gi.invocations.get_invocation_report_pdf,
            invocation_id=invocation_id,
            file_path=str(pdf_path)
        )
        background = BackgroundTasks()
        background.add_task(run_sync, _rmtree_sync, tmpdir)

        return FileResponse(
            path=pdf_path,
            filename=pdf_report_name,
            media_type="application/octet-stream",
            background=background
        )
    except Exception as exc:
        # Clean up immediately on error
        await run_sync(_rmtree_sync, tmpdir)
        raise HTTPException(status_code=500, detail=f"Failed to get PDF invocation report: {exc}")