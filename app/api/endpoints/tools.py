import logging
import uuid

from fastapi import APIRouter, Query, Path, Form, HTTPException, Request
from fastapi.responses import HTMLResponse
from fastapi.concurrency import run_in_threadpool

from bioblend.galaxy.objects.wrappers import HistoryDatasetAssociation, HistoryDatasetCollectionAssociation

from app.context import current_api_key
from app.api.schemas.tool import ToolExecutionResponse
from app.api.schemas.workflow import OutputDataset, CollectionOutputDataset
from app.galaxy import GalaxyClient 
from app.GX_integration.tool_manager import ToolManager
from app.api.socket_manager import ws_manager

from app.exceptions import InternalServerErrorException

log = logging.getLogger("tool_endpoints")

router = APIRouter()

# @router.get(
#     "/{tool_id:path}/form",
#     response_class=HTMLResponse,
#     summary = "Get dynamic galaxy tool form",
#     tags = ['Tools']
# )
async def get_tool_form(
    tool_id: str = Path(..., description="The Id of the Galaxy Tool"),
    history_id: str = Query(..., description="The Id of the history to select inputs from.") 
):
    """
    Generates and returns a dynamic HTML form for a specific galaxy tool.
    The form is populated with available datasets from the provided history.
    """

    galaxy_client = GalaxyClient(current_api_key.get())
    tool_manager = ToolManager(galaxy_client)

    try: 
        # Get the tool and history wrapper object
        tool = await run_in_threadpool(tool_manager.get_tool_by_id, tool_id)
        log.info(f"Tool name: {tool.name}")
        history = await run_in_threadpool(tool_manager.gi_object.histories.get, history_id)
        log.info(f"Hisotry: {history.name}")

        # Run the synchronous HTML build in a thread pool
        html_form = await tool_manager.build_html_form( tool = tool, history = history)

        return HTMLResponse(content = html_form)
    except Exception as e:
        raise InternalServerErrorException("Failed to build tool form")
    
# @router.post(
#     "/{tool_id:path}/histories/{history_id}/execute",
#     response_model= ToolExecutionResponse,
#     summary="Execute a Galaxy tool",
#     tags=["Tools"]   
# )
async def execute_tool(
    request: Request,
    tool_id: str = Path(..., description="The ID of the Galaxy tool to execute."),
    history_id: str = Path(..., description="The ID of the history for execution."),
    tracker_id: str | None = Query(None, description="Client-supplied tracker ID for WebSocket updates"),
):
    """
    Executes a tool using input data submitted via a form.
    This endpoint expects a `multipart/form-data` submission, as generated by the `/form` endpoint.
    It parses the form, transforms the data, invokes the tool, tracks it to completion, and returns the results.
    """
    
    galaxy_client = GalaxyClient(current_api_key.get())
    tool_manager = ToolManager(galaxy_client)

    # NOTE: tracker_id has to be sent from the client, but as a fallback option
    tracker_id = tracker_id or str(uuid.uuid4()) 
    try: 
        # Extract form data
        form_data = await request.form()
        log.info(f"Raw form data: {dict(form_data)}")
        
        # Transform form data to bioblend-compatible format
        bioblend_inputs = await run_in_threadpool(
            tool_manager.transform_form_data, 
            form_data, 
            tool_id, 
            )
        
        log.info(f"Transformed inputs: {bioblend_inputs}")
        
        # Execute tool with transformed inputs
        result = await tool_manager.run(
            tool_id = tool_id, 
            history_id = history_id, 
            inputs = bioblend_inputs,
            tracker_id= tracker_id,
            ws_manager = ws_manager
            
            )
        
        # Process output datasets
        output_datasets = []
        for ds in result["dataset"]:
            if isinstance(ds, HistoryDatasetAssociation):
                dataset_info = tool_manager.gi_object.gi.datasets.show_dataset(ds.id)
                output_datasets.append(
                    OutputDataset(
                        type="dataset",
                        id=ds.id,
                        name=ds.name,
                        file_ext=dataset_info.get("file_ext"),
                        visible=ds.visible,
                        peek=dataset_info.get("peek", ""),
                        data_type=dataset_info.get("data_type", ""),
                    )
                )
            elif isinstance(ds, HistoryDatasetCollectionAssociation):
                    elements = [
                        {
                            "identifier": e["element_identifier"],
                            "name": e["object"]["name"],
                            "id": e["object"]["id"],
                            "peek": tool_manager.gi_object.gi.datasets.show_dataset(e["object"]["id"]).get("peek", ""),
                            "data_type": tool_manager.gi_object.gi.datasets.show_dataset(e["object"]["id"]).get("data_type", ""),
                        }
                        for e in ds.elements
                    ]

                    output_datasets.append(
                        CollectionOutputDataset(
                            type="collection",
                            id=ds.id,
                            name=ds.name,
                            visible=ds.visible,
                            collection_type=ds.collection_type,
                            elements=elements,
                        )
                    )
                            
        return ToolExecutionResponse(
                    state = result["state"],
                    outputs = output_datasets,
                    message = result["message"]
                    )
    
    except Exception as e:
        log.error(f"Error executing tool: {str(e)}", exc_info=True)
        raise InternalServerErrorException("Tool execution failed")