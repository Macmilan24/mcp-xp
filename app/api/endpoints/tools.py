import logging

from fastapi import APIRouter, Query, Path, Form, HTTPException, Request
from fastapi.responses import HTMLResponse
from fastapi.concurrency import run_in_threadpool

from bioblend.galaxy.objects.wrappers import HistoryDatasetAssociation, HistoryDatasetCollectionAssociation

from app.context import current_api_key
from app.api.schemas.tool import ToolExecutionResponse
from app.api.schemas.workflow import OutputDataset, CollectionOutputDataset
from app.bioblend_server.galaxy import GalaxyClient 
from app.bioblend_server.executor.tool_manager import ToolManager

log = logging.getLogger("tool_endpoints")

router = APIRouter()

@router.get(
    "/{tool_id:path}/form",
    response_class=HTMLResponse,
    summary = "Get dynamic galaxy tool form",
    tags = ['Tools']
)
async def get_tool_form(
    tool_id: str = Path(..., description="The Id of the Galaxy Tool"),
    history_id: str = Query(..., description="The Id of the history to select inputs from.") 
):
    """
    Generates and returns a dynamic HTML form for a specific galaxy tool.
    The form is populated with available datasets from the provided history.
    """

    galaxy_client = GalaxyClient(current_api_key.get())
    tool_manager = ToolManager(galaxy_client)

    try: 
        # Get the tool and history wrapper object
        tool = await run_in_threadpool(tool_manager.get_tool_by_id, tool_id)
        log.info(f"Tool name: {tool.name}")
        history = await run_in_threadpool(tool_manager.gi_object.histories.get, history_id)
        log.info(f"Hisotry: {history.name}")

        # Run the synchronous HTML build in a thread pool
        html_form = await run_in_threadpool(
            tool_manager.build_html_form,
            tool,
            history
        )
        return HTMLResponse(content = html_form)
    except Exception as e:
        raise HTTPException(status_code = 500 , detail = f"failed to build tool form: {e}")
    
@router.post(
    "/{tool_id:path}/histories/{history_id}/execute",
    response_model= ToolExecutionResponse,
    summary="Execute a Galaxy tool",
    tags=["Tools"]   
)
async def execute_tool(
    request: Request,
    tool_id: str = Path(..., description="The ID of the Galaxy tool to execute."),
    history_id: str = Path(..., description="The ID of the history for execution.")
):
    """
    Executes a tool using input data submitted via a form.
    This endpoint expects a `multipart/form-data` submission, as generated by the `/form` endpoint.
    It parses the form, transforms the data, invokes the tool, tracks it to completion, and returns the results.
    """
    
    galaxy_client = GalaxyClient(current_api_key.get())
    tool_manager = ToolManager(galaxy_client)

    try: 
        # Extract form data
        form_data = await request.form()
        log.info(f"Raw form data: {dict(form_data)}")
        
        # Transform form data to bioblend-compatible format
        bioblend_inputs = await run_in_threadpool(
            tool_manager.transform_form_data, 
            form_data, 
            tool_id, 
            )
        
        log.info(f"Transformed inputs: {bioblend_inputs}")
        
        # Get history object
        history = await run_in_threadpool(tool_manager.gi_object.histories.get, history_id)
        
        # Execute tool with transformed inputs
        result = await run_in_threadpool(
            tool_manager.run, 
            tool_id, 
            history, 
            bioblend_inputs
        )
        
        # Process output datasets
        output_datasets = []
        for ds in result["dataset"]:
            if isinstance(ds, HistoryDatasetAssociation):
                dataset_info = tool_manager.gi_object.gi.datasets.show_dataset(ds.id)
                output_datasets.append(
                    OutputDataset(
                        type="dataset",
                        id=ds.id,
                        name=ds.name,
                        file_ext=dataset_info.get("file_ext"),
                        visible=ds.visible,
                        peek=dataset_info.get("peek", ""),
                        data_type=dataset_info.get("data_type", ""),
                    )
                )
            elif isinstance(ds, HistoryDatasetCollectionAssociation):
                    elements = [
                        {
                            "identifier": e["element_identifier"],
                            "name": e["object"]["name"],
                            "id": e["object"]["id"],
                            "peek": tool_manager.gi_object.gi.datasets.show_dataset(e["object"]["id"]).get("peek", ""),
                            "data_type": tool_manager.gi_object.gi.datasets.show_dataset(e["object"]["id"]).get("data_type", ""),
                        }
                        for e in ds.elements
                    ]

                    output_datasets.append(
                        CollectionOutputDataset(
                            type="collection",
                            id=ds.id,
                            name=ds.name,
                            visible=ds.visible,
                            collection_type=ds.collection_type,
                            elements=elements,
                        )
                    )
                            
        return ToolExecutionResponse(
                    state = result["state"],
                    outputs = output_datasets,
                    stdout = result["stdout"],
                    stderr = result["stderr"],
                    error_message = result["error"]
                    )
    
    except Exception as e:
        log.error(f"Error executing tool: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Tool execution failed: {str(e)}")